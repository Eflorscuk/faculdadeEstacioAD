Aula 02 0 Modelos de Ciclo de Vida de Software

Objetivos
* Definir o ciclo de vida de software
* Listar modelos de ciclo de vida de software: cascata, evolutivo, iterativo e incremental
* Discutir os modelos RAD, prototipação, espiral e RUP

Por que é importante utilizar um modelo de ciclo de vida para desenvolver softwares?
-> O modelo de ciclo de vida é a primeira escolha s ser feita no processo
de software, que abrange a vida do sistema, desde a definição de requisitos
até a conclusáo do projeto e entrega do produto.


Esse ciclo de vida está agrupado em fases, como: definição de requisitos, análise
, projeto, desenvolvimento, teste e implantação. Em cada fase são definidas,
além das atividades, as funções e responsabilidades de cada membro da equipe
do projeto.


Principais modelos de ciclo de vida de software
*Cascata (Waterfall)
*Modelo em V
*Modelo incremental
*Evolutivo
*Iterativo e Incremental
*RAD
*Prototipagem
*Espiral
*Modelo de ciclo de vida associado ao RUP


O modelo castaca (waterfall)
O modelo cascata, ou sequencial linear, é considerado o mais antigo e o mais
usado na engenharia de software em todo o mundo

Seu nome tem origem ao fato de que a sequência com que cada fase do desenvolvimento
dependia do término da fase anterior, ou seja, o resultado de uma fase era utilizado
com a entrada para a fase seguinte

Nesse modelo, a ênfase maior ficava por conta das fases de análise e projeto antes
de iniciar a implementação

É possível voltar apara uma etapa anterior

Suas etapas são:
1. Levantamento de Requisitos:
Levantamento de requisitos com o cliente, para entender suas expectativas e 
definir quais funcionalidades devem ser implementadas no sistema.
2. Projeto:
Aqui é feito um planejamento das etapas seguintes através da:
*Criação de um cronograma
*Definição de tarefas com base nos requisitos
*Estimativa de finalização de cada etapa
*montagem do time de desenvolvimento
*modelagem da interface e arquitetura do sistema etc.
3. Implementação:
*Codificação do software de acordo com os requisitos e especificações do projeto.
4. Testes:
Código pronto, se faz necessário testá-lo
5. Implementação e manutenção




Vantagens:
*A fase de análise de requisitos (única) leva ao projeto do sistema e, por sua vez, antes da fase de codificação
*Ao final de cada fase e antes de iniciar a seguinte, devem ser feitas revisões com a participação do usuário
*Cada etapa (fase) deve passar por aprovação e documentação, visando o passo seguinte

Desvantagens:
*O fluxo sequencial proposto pelo modelo geralmente não é seguido
*O modelo cascata exige que os requisitos sejam claramente definidos e completos, pois são estabelecidos na fase incial do projeto
*O módulo executável para teste somente fica disponível ao final do projeto


Modelo em V
Variação do cascata
Ajusta as atividades de testes com as fases de análise e projeto
Também é sequencial, sendo assim, cada fase necessita ser concluída antes do início da seguinte fase

Vantages:
*Maior chance de sucesso ao relacionar com o modelo cascata
*Isso pelo fato do desenvolvimento em planos de teste desde as fases iniciais
*Funciona bem para projetos pequenos, nos quais os requisitos são facilmente entendidos

Desvantagens:
*Tão rigidos quanto o cascata
*Requisitos devem ser estabelecidos corretamente e de forma clara no início do projeto


Incremental
Funcionalidades ou necessidades são integradas de forma segmentada e em série
até a conclusão do projeto final

O modelo incremental propõe a aumentar pouco a pouco o software, conforme as necessidades
surgem

Deve ser adotado quando os requisitos são claramente conhecidos na fase inicial
do desenvolvimento e há necessidade de entrega de um modulo ou funcionalidade do
software em curto espaço de tempo

Cada incremento do projeto gera uma nova versão do software

Vantagens:
*A entrega da primeira versão apresenta um menor custo e menos tempo se
comparado com os modelos em cascata e em V
*Poucos riscos associados ao desenvolvimento dos incrementos devido ao seu tamanho reduzido

Desvantagens do modelo incremental
*No caso de requisitos mal definidos ou incompletos, alguns incrementos podem
ser retrabalhados, o que gera custos e atrasos


Modelo evolutivo
Visa o desenvolvimento de software a partir de requisitos de protótipos
iniciais

Versões parciais são desenvolvidas para atender aos requisitos levantados inicialmente.

A primeira versão é usada para refinar os requisitos visando uma segunda versão e, a partir do conhecimento obtido com o uso,
o desenvolvimento prossegue, evoluindo, então, o produto

Vantagens
*É usado quando os requisitos se apresentam incompletos no início do desenvolvimento
*Com o uso do sistema, o conhecimento sobre o produto vai aumentando e, consequentemente,
melhorando os requisitos

Desvantagens
*É necessário um rigido controle sobre os custos, grande preocupação com
cronograma e com configuração do software
*Usuários precisam estar preparados quanto aos resultados iniciais, que podem
parecer insatisfatórios


Iterativo e incremental
Modelo que trouxe bastante agilidade e flexibilidade

O modelo divide o desenvolvimento do software em pequenos ciclos ou módulos
ou novas funcionalidades. Cada funcionalidade deve corresponder a uma necessidade
do usuário à medida que for necessária à sua construção

Para o desenvolvimento de cada funcionalidade, é utilizado um pequeno modelo em
cascata, objetivando, assim, atender às necessidades sempre que se fizer necessário


RAD (Rapid Application Development)
É um modelo de desenvolvimento de software incremental que enfatiza um ciclo
de desenvolvimento curto e se apresenta de forma sequencial linear

Um projeto de software que utiliza o RAD consome em média de 60 a 90 dias

Exige requisitos bem definidos e estabilizados, além de escopo restrito e com
possibilidade de ser dividio em módulos

Vantagens:
*O ciclo de desenvolvimento é extremamente curto se comparado com os demais modelos
*Distribuição de tarefas é facilitada enter as equipes de desenvolvimento

Desvantagens:
*Requer equipes de desenvolvimento adequadas para atender à demanda de projetos grandes e escaláveis
*Não é apropriado quando os riscos são grandes
*Não é apropriado quando o sistema precisa interagir com outros sistemas


Prototipagem
É utilizado quando é definido um conjuto de objetivos gerais para o software, mas
os detalhes não estão claramente definidos como requisitos de entrada, processamento
e saída

Ele começa com comunicação do engenheiro de software com o cliente

Definição em linhas gerais dos objetivos do protótipo

Vantagens:
*O protótipo deve ser avaliado pelo usuário
*A interação do usuário com o protótipo é fundamental para ajustar as necessidades
funcionais

Desvantagens:
*O usuário pode pensar que a maior parte do software está pronta
*O protótipo pode crescer de maneira não planejada, com risco de se tornar um incremento funcional
*O protótipo pode confundir o usuário iludido por um desempenho melhor do que um incremento funcional
*O fato de o protipo não implementar toda a funcionalidade pode causar frustração
para o usuário quando o sistema completo é entregue


Modelo Espiral
É dividido em duas etapas principais:
*Análise de Riscos
*Prototipagem

A cada novo ciclo, esse modelo testa constantemente os erros que podem vir a
acontecer

Cada repetição do ciclo deve ocorrer no projeto:
*Determinação de objetivos
*Avaliação e redução de riscos
*Desenvolvimento e validação
*Planejamento da próxima iteração

Vantagens
*Muita análise de riscos
*Bom para projetos grandes e críticos
*Software é produzido cedo no ciclo de vida

Desvantagens
*Pode ser custoso
*Análise de riscos requer experiência
*Não se aplica bem a projetos menores


RUP (Rational Unified Process)
Processo que integra ciclos, fases e disciplinas, visando a qualidade no gerenciamento
de projetos

Suas fases são:
*Concepção
Define o escopo do projeto
*Elaboração
Planeja o projeto, define e valida a arquitetura
*Construção
Construção do software
*Transição
Implantação do software

Referências
PFLEEGER, Shari Lawrence. Engenharia de Software: teoria e prática. 2. ed. São Paulo: Pearson, 2003.
PRESSMAN, R. S. Engenharia de Software: uma abordagem profissional. 8. ed. Rio de Janeiro: Amgh, 2016
SOMMERVILLE, Ian. Engenharia de Software. 9. ed. São Paulo: Pearson, 2011.
BOOCH, G.; RUMBAUGH, J.; JACOBSON, I. UML: guia do usuário. Rio de Janeiro: Campus, 2000.


